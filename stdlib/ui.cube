native libs/libui
{
    void ui_start();
    void ui_stop();
    num ui_create_window(str, num, num);
    void ui_destroy_window(num);
    list ui_run_cycle();
    void ui_run_forever();
    bool ui_has_quit();
    bool ui_load(num, str);
    bool ui_on_event(num, str, str);
    dict ui_get_event_args(str);
    list ui_get_property(num, str, str);
    bool ui_set_property(num, str, str, str);
    dict ui_get_obj(num, str);
    void ui_antialias(num, bool);
    void ui_rm_shape(num, num);
    num ui_add_shape(num, dict);
    void ui_update_shape(num, dict);
}

import shapes;

class UI
{
    static var windows = [];
    static var FPS = 60;

    static func start()
    {
        ui_start();
    }

    static func stop()
    {
        ui_stop();
    }

    static func forever()
    {
        var lastFPS = UI.FPS;
        var delay = int(1000 / lastFPS);

        var fps = 60;
        var startFrame = clock();
        var start = startFrame;
        var current;
        var dt;
        while(UI.running())
        {
            current = clock();
            dt = current - startFrame;
            fps = 1 / dt;
            UI.cycle(fps, dt, current - start);
            startFrame = clock();
            wait(delay);
            if(lastFPS != UI.FPS)
            {
                lastFPS = UI.FPS;
                delay = int(1000 / lastFPS);
            }
        }
        UI.stop();
    }

    static func cycle(fps, dt, T)
    {
        for(var i = 0; i < len(UI.windows); ++i)
        {
            var window = UI.windows[i];
            if(window.update is func)
            {
                window.update(window, fps, dt, T);
            }
            if(len(window.shapes) > 0)
            {
                for(var j = 0; j < len(window.shapes); ++j)
                {
                    var shape = window.shapes[j];
                    if(shape.updated)
                    {
                        ui_update_shape(window.id, shape.dict());
                        shape.updated = false;
                    }
                }
            }
        }
        var events = ui_run_cycle();
        for(var i = 0; i < len(events); ++i)
        {
            var ev = events[i];
            var parts = ev.split(':');
            var id = num(parts[0]);
            var obj = parts[1];
            var event = parts[2];
            var target = parts[3];
            for(var j = 0; j < len(UI.windows); ++j)
            {
                var window = UI.windows[j];
                if(window.id == id)
                {
                    if(num(target) == window.id)
                        target = none;
                    var onId = '{}:{}'.format(obj, event);
                    if(window.actions.exists(onId))
                    {
                        var action = window.actions.get(onId, none);
                        var evArgs = ui_get_event_args(ev);
                        action(window, target, evArgs);
                    }
                }
            }
        }
        return true;
    }

    static func running()
    {
        return !ui_has_quit();
    }

    static func addWindow(w)
    {
        UI.windows.add(w);
    }

    static func removeWindow(w)
    {
        UI.windows.remove(w);
    }
}

class Window
{
    var id = none;
    var update = none;
    var actions = {};
    var shapes = [];

    func init(name, width, height)
    {
        if(width is none)
            width = 600;
        if(height is none)
            height = 480;
        this.id = ui_create_window(name, width, height);
        UI.addWindow(this);
    }

    func close()
    {
        ui_destroy_window(this.id);
        UI.removeWindow(this);
    }

    func load(fileName)
    {
        return ui_load(this.id, fileName);
    }

    func antialias(enabled)
    {
        ui_antialias(this.id, enabled);
    }

    func on(obj, event, action)
    {
        if(obj is none)
            obj = this.id;
        var onId = '{}:{}'.format(obj, event);
        this.actions[onId] = action;

        return ui_on_event(this.id, obj, event);
    }

    func onUpdate(fn)
    {
        this.update = fn;
    }

    func obj(name)
    {
        return ui_get_obj(this.id, name);
    }

    func get(obj, prop)
    {
        return ui_get_property(this.id, obj, prop);
    }

    func set(obj, prop, value)
    {
        return ui_set_property(this.id, obj, prop, value);
    }

    func clear(shape)
    {
        ui_rm_shape(this.id, shape.id);
    }

    func draw(shape)
    {
        if(shape is string)
        {
            shape = Text(shape);
        }
        var id = ui_add_shape(this.id, shape.dict());
        if(id == -1)
            return none;
        shape.id = id;
        this.shapes.add(shape);
        return shape;
    }
}